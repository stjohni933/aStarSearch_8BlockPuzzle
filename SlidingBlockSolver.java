/**
 * @(#)SlidingBlockSolver.java
 * This class contains the A* search algorithm utilized in finding a solution to the sliding block puzzle. The heuristic function for this search is the calculated Manhattan Distance of a given board state.
 * The algorithm will build an implicit tree of SldingBlockStates, each composed of a BoardState at the current step, the number of moves it took to reach that state, and the previous BoardState. 
 * The tree will be represented by a priority queue data structure. Each SlidingBlockState's priority will be the result of the heuristic function.
 *
 * @author Iain St. John
 * CSC 342 -- Artificial Intelligence -- Project One
 * @version 1.00 2016/2/13
 */
 
 
import java.util.*;

public class SlidingBlockSolver {
	private PriorityQueue<SlidingBlockState> states; //our priority queue of SlidingBlockStates
    
    /**
     *Constructor that takes a specified starting state of the puzzle, creates it, and adds it to a created priority queue
     *
     *@param start -- initial SlidingBlockState
     */
     public SlidingBlockSolver(SlidingBlockState start) {
     	states = new PriorityQueue<SlidingBlockState>(100);
     	states.offer(start);
     }
     
   /**
     *This method checks the starting configuration of an 8-Block Puzzle to make sure that it's valid. It checks if the starting point passed
     *to the SlidingBlockSolver's constructor is already a solved configuration, or if it is unsolvable. 
     *It also makes sure there are no tile repeats, and that all values lie in the range of 0-8
     *
     *@return String -- a string that either states the reason why an initial state isn't valid, or that it passed.
     */
     public String checkStartValidity() {
     	if(this.states.peek().getCurrState().isSolved()) {
     		return "solved";
     	}
     	else if(!this.states.peek().getCurrState().isSolvable()) {
     		return "unsolvable";
     	}
     	else if(!this.states.peek().getCurrState().noRepeats()) {
     		return "repeats";
     	}
     	else if(!this.states.peek().getCurrState().allInRange()) {
     		return "outlier";
     	}
     	else {
     		return "pass";
     	}
     } 
    
  /**
    *This is our A* search function, which employs the A star searching algorithm to find the solution to a given configuration of the 8-Block puzzle.
    *It uses a priority queue of SlidingBlockStates to search for the solution, printing out each step along the way.
    *
    */
    public void aStarSearch() {
    	boolean goalReached = false; //track whether or not we've reached a goal state
    	int step = 0; //the step we are on
    	
    	//print a message that we are starting our search
    	System.out.println("The search for the solution has commenced!");
    	
    	
    	//while we still have states in our queue and we haven't found the goal, continue
    	while(!goalReached) {
    		
    		//because 2 goal states are included, the solver will sometimes move towards one because it yields a lower Manhattan Distance to find that it leads to an unsolvable state.
    		//This means that the solver will sometimes "back up." Check for that case, and print a notice that we're checking a previously added state.
    		int lastStep = 0;
    		SlidingBlockState next = states.peek();
    		if(next.getMoves() < step) {
    			lastStep = next.getMoves();
    			System.out.println("Backing up " + (step - lastStep) + " steps, to step " + lastStep);
    			next.setMoves(step);
    		}
    		//remove closest state and increment the step
    		SlidingBlockState current = states.poll();
    		step++;
    		
    		
    		System.out.println(current);
    		
    		//check if we have found a goal state
    		if(current.getCurrState().isSolved()) {
    			goalReached = true;
    			System.out.println(current.goalStateString());
    			break;
    		}
    		
    		//if we have not found our goal state, we need to keep looking. Generate our frontier
    		SlidingBlockState horizon[] = current.getFrontier();
    		
    		//add each game state on the horizon to the queue, so long as it isn't our last state, and it isn't already in the queue.
    		for(SlidingBlockState sbs : horizon) {
    			
    			//if last state is null, we're on the first state, and don't need to check for redundant states.
    			if((current.getLastState()) == null) {
    				sbs.setMoves(step);
    				//tell the state which goal to look for
    				states.offer(sbs);
    			}
				
				//do not add the state from which we arrived.
    			else if(!(sbs.getCurrState().equals(current.getLastState()))) {
					if(!(states.contains(sbs))) {
						sbs.setMoves(step);
						//tell the state which goal to look for
						states.offer(sbs);
					}
    			}
    		}
    	} //end of while loop
		
    } //end of aStarSearch method
    
    //returns string generated by the Priority queue's toString method
    public String toString() {
    	return states.toString();
    } 
}